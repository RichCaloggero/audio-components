<!--<link rel="import" href="../polymer/lib/elements/dom-if.html">-->
<!--<link rel="import" href="../polymer/lib/elements/dom-repeat.html">-->

<dom-module id="audio-control">
<template>
<style>
:host {
display: block;
}

:host .field {
display: inline;
}

.lfo-ui {display:none;}
</style>

<div class="audio-control" role="region" aria-label$="[[label]]">
<span class="label">[[label]]</span>

<ui-list name="type" label="automation type" value="{{type}}" values='["function","wave"]'></ui-list>

<div class="field" data-name="value">
<label>function</label>
<br><input type="text" value="{{value::change}}">
</div>

<div class="lfo-ui" role="region" aria-label="LFO">
<div class="field" data-name="wave">
<label>wave</label> as</label>
<br><input type="text" value="{{wave::change}}">
</div>

<ui-number name="frequency" label="frequency" value="{{frequency}}" min="0.05" max="5.0" step="0.05"></ui-number>
<ui-number name="lfoGain" label="gain" value="{{lfoGain}}" min="-100.0" max="100.0"></ui-number>
<ui-number name="center" label="center" value="{{center}}" min="-100.0" max="100.0"></ui-number>
</div><!-- .lfo-ui -->

</div>
</template>

<script>
// audio-control
"use strict";

(function () {
var instanceCount  = 0;
var automationQueue = [];

window.AudioControl = class AudioControl extends _AudioContext_ {
static get is() { return "audio-control"; }

static get properties () {
return {
label: {
type: String,
value: ""
}, // label

parameter: {
type: String,
value: "",
notify: true,
//observer: "parameterChanged"
}, // parameter

value: {
type: String,
value: "",
notify: true,
observer: "valueChanged"
}, // value

wave: {
type: String,
value: "",
notify: true,
observer: "waveChanged"
}, // wave

type: {
type: String,
value: "function",
notify: true,
observer: "typeChanged"
}, // type

frequency: {
type: Number,
value: 1.0,
notify: true,
observer: "frequencyChanged"
}, // frequency

center: {
type: Number,
value: "0.5",
notify: true,
observer: "centerChanged"
}, // center

lfoGain: {
type: Number,
value: "0.0",
notify: true,
observer: "lfoGainChanged"
} // lfoGain
}; // return
} // get properties


constructor () {
super ();
instanceCount += 1;
this._id = AudioControl.is + instanceCount;
this._automation = null;
this._lfoGain = audio.createGain();
console.log (`constructor: ${this.id} created`);
} // constructor

_attachDom(dom) {
this.shadowRoot = this.attachShadow({mode: 'open', delegatesFocus: true});
super._attachDom(dom);
} // _attachDom

connectedCallback () {
super.connectedCallback ();
console.log (`${this._id} connected to ${this.parentElement.localName}`);
this.addFieldLabels ();
} // connectedCallback

setupAutomation() {
this.stop ();
if (!this.value) {
return;
} // if

let element = this.parentElement;
console.log (`setting up automation for ${element._id}`);

if (! (this.parameter in element)) {
alert (`setupAutomation: parameter ${this.parameter} not in ${element.localName}`);
return;
} // if
this._automationTarget = element;

if (this.type === "function") {
this._automationInterval = this.interval || 100; // milliseconds
let f = compileFunction (this.value, "t").bind(element);

if (f) {
console.log (`function: ${f}`);
this._automator = f;
addToAutomationQueue (this);

} else {
alert ("invalid function: " + this.value);
return;
} // if
} // automation type

this.start ();
} // setupAutomation

start () {
if (this.type === "wave") this._startWaveAutomation ();
else this._startFunctionalAutomation ();
} // start

_startWaveAutomation () {
if (! this.wave) return;

this._audioParam = getAudioParam(this.parameter, this._automationTarget);
if (typeof(this._audioParam) === "string" || this._audioParam instanceof String) {
alert (`parameter ${parameter} not automatable via wave - change type to 'function' and try again`);
return;
} // if

this._wave = createWave (this.wave);
this._startOscillator ();
} // _startWaveAutomation

_startFunctionalAutomation () {
if (! this._automator) return;
this._automation = setInterval (() => {
try {
this._automationTarget[this.parameter] = this._automator(audio.currentTime);
} catch (e) {
alert (e);
this.value = "";
this.stop ();
removeFromAutomationQueue (this);
} // catch
}, this._automationInterval);

console.log (`${this._id}: starting automation for parameter ${this.parameter} of ${this._automationTarget? this._automationTarget.localName : null} using interval ${this._automationInterval}`);
} // start

stop () {
console.log (`${this._id}: stopping automation for parameter ${this.parameter} of ${this._automationTarget? this._automationTarget.localName : null}`);
if (this._oscillator) {
this._oscillator.stop ();
removeFromAutomationQueue (this._oscillator);
this._oscillator = null;
} // if

if (this._automation) {
clearInterval (this._automation);
} // if
} // stop

static startAllAutomation () {
automationQueue.forEach ((element) => element.start());
} // startAllAutomation

static stopAllAutomation () {
automationQueue.forEach ((element) => element.stop());
} // stopAllAutomation


_startOscillator () {
let oscillator = audio.createOscillator ();
oscillator.setPeriodicWave (this._wave);
oscillator.frequency.value = this.frequency || 1.0;
this._audioParam.value = this.center;

oscillator.connect (this._lfoGain).connect (this._audioParam);
oscillator.start ();
console.log (`- oscillator started`);

this._oscillator = oscillator;
addToAutomationQueue (oscillator);
} // _startOscillator


frequencyChanged (value) {
if (this._oscillator) this._oscillator.frequency.value = value;
} // frequencyChanged

parameterChanged (value) {
console.log(`parameter ${value}`);
} // parameterChanged

valueChanged (value) {
this.stop ();
this.setupAutomation ();
} // valueChanged

waveChanged (value) {
this.stop ();
this.setupAutomation ();
} // waveChanged

typeChanged (value) {
console.log (`typeChange: ${value}`);
this.stop ();
this.shadowRoot.querySelector(".lfo-ui").style.display = (value === "wave")?
"block" : "none";
this.shadowRoot.querySelector(".field[data-name=value]").style.display = (value === "function")?
"block" : "none";

this.setupAutomation ();
} // typeChanged

lfoGainChanged (value) {
this._lfoGain.gain.value = value;
} // lfoGainChanged

centerChanged (value) {
if (this._audioParam) this._audioParam.value = value;
} // centerChanged

} // class AudioControl

function addToAutomationQueue (element) {
automationQueue.push (element);
console.log (`added ${element.label || element._id} to automation queue`);
} // addToAutomationQueue

function removeFromAutomationQueue (element) {
let found = automationQueue.indexOf(element);
if (found >= 0) {
automationQueue.splice (found, 1);
console.log (`removed ${element.label || element._id} from automation queue`);
} // if
} // removeFromAutomationQueue

function getAudioParam (parameter, element) {
var properties = element.constructor.properties;
return element._audioNode[properties[parameter].audioParam] || parameter;
} // getAudioParam

function createWave (_wave) {
let freqs = _wave.split (",");
if (! freqs || !(freqs instanceof Array)) {
alert (`createWave: invalid value  ${_wave} - must be numbers separated by comma`);
throw ("invalid value");
} // if

console.log (`createWave: freqs=${freqs}`);
let real = new Float32Array(freqs.length+1);
let imaginary = new Float32Array(freqs.length+1);

freqs.forEach ((freq,i) => {
let values = freq.trim().split(" ");
real[i] = values[0];
imaginary[i] = (values.length === 2)?
values[1] : 0.0;
}); // forEach

console.log (`createWave: ${real} ${imaginary}`);
return audio.createPeriodicWave (real, imaginary, {disableNormalization: true});
} // createWave

function compileFunction (text, parameter) {
try {
return new Function (parameter,
`with (Math) {return ${text};}`);

} catch (e) {
alert (e);
return null;
} // try
} // compileFunction

window.customElements.define(AudioControl.is, AudioControl);
})();
</script>
</dom-module>
