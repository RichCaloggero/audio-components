<!--<link rel="import" href="../polymer/lib/elements/dom-if.html">-->
<!--<link rel="import" href="../polymer/lib/elements/dom-repeat.html">-->

<dom-module id="audio-control">
<template>
<style>
:host {
display: block;
}

:host .field {
display: inline;
}

.lfo-ui {display:none;}
</style>

<div class="audio-control">
<span class="label">[[label]]</span>
<ui-list name="type" label="automation type" value="{{type}}" values='["function","wave"]'></ui-list>

<div class="field" data-name="value">
<label>automating {{parameter}} as
<br><input type="text" value="{{value::change}}">
</label>
</div>

<div class="lfo-ui" role="region" aria-label="LFO">
<ui-number name="frequency" label="frequency" value="{{frequency}}" min="0" max="20.0"></ui-number>
<ui-number name="gain" label="gain" value="{{lfoGain}}" min="-1.0" max="1.0"></ui-number>
<ui-number name="center" label="center" value="{{center}}" min="0.0" max="999.0"></ui-number>
</div><!-- .lfo-ui -->

</div>
</template>

<script>
"use strict";

(function () {
var instanceCount  = 0;
var automationQueue = [];

window.AudioControl = class AudioControl extends _AudioContext_ {
static get is() { return "audio-control"; }

static get properties () {
return {
parameter: {
type: String,
value: "",
notify: true,
//observer: "parameterChanged"
}, // parameter

value: {
type: String,
value: "",
notify: true,
observer: "valueChanged"
}, // value

type: {
type: String,
value: "function",
notify: true,
observer: "typeChanged"
} // type
}; // return
} // get properties


constructor () {
super ();
instanceCount += 1;
this._id = AudioControl.is + instanceCount;
this._automation = null;
this.label = `controling ${this.parameter}`;
console.log (`${this.id} created`);
} // constructor

_attachDom(dom) {
this.shadowRoot = this.attachShadow({mode: 'open', delegatesFocus: true});
super._attachDom(dom);
} // _attachDom

connectedCallback () {
super.connectedCallback ();
console.log (`${this._id} connected to ${this.parentElement.localName}`);
this.addFieldLabels ();
} // connectedCallback

setupAutomation() {
if (!this.value) return;
let element = this.parentElement;
console.log (`setting up automation for ${element._id}`);

if (!(this.parameter in element)) {
alert (`setupAutomation: parameter ${this.parameter} not in ${element.localName}`);
return;
} // if

if (this.type === "wave") {
this._audioParam = getAudioParam(this.parameter, element);
if (typeof(this._audioParam) === "string" || this._audioParam instanceof String) {
alert (`parameter ${parameter} not automatable via wave - change type to 'function' and try again`);
return;
} // if

this._wave = createWave (this.value);
this.startOscillator ();

} else {
this._automationInterval = this.interval || 100; // milliseconds
let f = this.compileFunction (this.value, "t").bind(element);

if (f) {
console.log (`function: ${f}`);
this._automator = f;
this._automationTarget = element;
addToAutomationQueue (this);
this.start ();

} else {
alert ("invalid function: " + this.value);
} // if
} // automation type
} // setupAutomation

start () {
this.stop ();
this._automation = setInterval (() => {
try {
this._automationTarget[this.parameter] = this._automator(audio.currentTime);
} catch (e) {
alert (e);
this.value = "";
this.stop ();
removeFromAutomationQueue (this);
} // catch
}, this._automationInterval);

console.log (`${this._id}: starting automation for parameter ${this.parameter} of ${this._automationTarget.localName} using interval ${this._automationInterval}`);
} // start

stop () {
if (this.oscillator && this.type === "wave") {
this.oscillator.stop ();
return;
} // if

if (this._automation) {
clearInterval (this._automation);
console.log (`${this._id}: stopping automation for parameter ${this.parameter} of ${this._automationTarget.localName} using interval ${this._automationInterval}`);
} // if
} // stop

static startAllAutomation () {
automationQueue.forEach ((element) => element.start());
} // startAllAutomation

static stopAllAutomation () {
automationQueue.forEach ((element) => element.stop());
} // stopAllAutomation


parameterChanged (value) {
console.log(`parameter ${value}`);
} // parameterChanged

valueChanged (value) {
this.stop ();
this.setupAutomation ();
} // valueChanged

typeChanged (value) {
console.log (`typeChange: ${value}`);
this.stop ();
this.shadowRoot.querySelector(".lfo-ui").style.display = (this.type === "wave")?
"block" : "none";

this.setupAutomation ();
} // typeChanged

compileFunction (text, parameter) {
try {
return new Function (parameter,
`with (Math) {return ${text};}`);

} catch (e) {
alert (e);
return null;
} // try
} // compileFunction

startOscillator () {
let oscillator = audio.createOscillator ();
oscillator.setPeriodicWave (this._wave);
oscillator.frequency.value = this.frequency || 1.0;

let lfoGain = audio.createGain ();
lfoGain.gain.value = this.lfoGain || 0.5;
if (this.center) this._audioParam.value = this.center;

oscillator.connect (lfoGain).connect (this._audioParam);
oscillator.start ();
console.log (`- oscillator started`);

this.oscillator = oscillator;
addToAutomationQueue (oscillator);
} // startOscillator

} // class AudioControl

function addToAutomationQueue (element) {
automationQueue.push (element);
console.log (`added ${element.label || element._id} to automation queue`);
} // addToAutomationQueue

function removeFromAutomationQueue (element) {
let found = automationQueue.indexOf(element);
if (found >= 0) {
automationQueue.splice (found, 1);
console.log (`removed ${element.label || element._id} from automation queue`);
} // if
} // removeFromAutomationQueue

function getAudioParam (parameter, element) {
var properties = element.constructor.properties;
return element._audioNode[properties[parameter].audioParam] || parameter;
} // getAudioParam

function createWave (_wave) {
let freqs = _wave.split (",");
if (! freqs || !(freqs instanceof Array)) {
alert (`createWave: invalid value  ${_wave} - must be numbers separated by comma`);
throw ("invalid value");
} // if

console.log (`createWave: freqs=${freqs}`);
let real = new Float32Array(freqs.length+1);
let imaginary = new Float32Array(freqs.length+1);

freqs.forEach ((freq,i) => {
let values = freq.trim().split(" ");
real[i] = values[0];
imaginary[i] = (values.length === 2)?
values[1] : 0.0;
}); // forEach

console.log (`createWave: ${real} ${imaginary}`);
return audio.createPeriodicWave (real, imaginary);
} // getWave

window.customElements.define(AudioControl.is, AudioControl);
})();
</script>
</dom-module>
